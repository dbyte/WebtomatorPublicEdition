# shop.shopDao.py
import json
from typing import ClassVar, Optional, List, Union
import pathlib as pl

import tinydb as tdb

import debug.logger as clog
from config.base import APP_USERDATA_DIR
from shop.product import Product, Size
from shop.shop import Shop
from storage.tinyDao import TinyDao

logger = clog.getLogger(__name__)


class TinyShopDao(TinyDao):
    _TABLE_NAME: ClassVar[str] = "Shops"
    _DEFAULT_PATH: ClassVar = APP_USERDATA_DIR / "Shops.json"

    def __init__(self, path: pl.Path = None):
        path = path or self._DEFAULT_PATH
        super().__init__(path=path, table=self._TABLE_NAME)

    def saveAll(self, data: List[Shop]) -> None:
        """ Overwrite all Shop data at the target DB with a given Shop list.

        :param data: A list of Shop objects.
        :return: None
        :raises:
        """
        # Type check
        if (not isinstance(data, list)) or (not all(isinstance(i, Shop) for i in data)):
            raise TypeError("Could not save Shops. All elements must be of type 'Shop'.")

        # Delete all data of the 'Shops' table
        super().saveAll(list())  # raises

        # Add given shops to table
        shops = data
        for shop in shops:
            self.insert(shop)

    def loadAll(self) -> Optional[List[Shop]]:
        """ Load all shops from the target DB as a list with Shop elements.

        :return: A Shop list if non-empty Shops where found, else None
        """
        # shopItems is a list of dict objects, generated by a TinyDB table query
        shopItems = super().loadAll()  # raises
        # Decode these dict objects into a list of Shop objects
        shops = self._decodeShops(shopItems)
        return shops if len(shops) > 0 else None

    def insert(self, data: Shop) -> None:
        """ Adds a Shop record to the DB.

        :param data: Shop object
        :return: None
        :raises:
        """
        # Type check. Note: We do not validate any shop values here by now, nor do we check
        # for any empty values.
        if not isinstance(data, Shop):
            raise TypeError("Could not save Shop. Argument 'data' must be of type 'Shop'.")

        # Deep conversion: Shop object to dict, which is the expected data type of super.update()
        dataDict = self._encodeShop(data)  # raises

        # Insert record.
        super().insert(dataDict)  # raises

    def update(self, data: Shop) -> None:
        """ Updates a Shop record (inside the 'Shops' table) with the given Shop object.

        :param data: Shop object
        :return: None
        :raises:
        """
        # Type check. Note: We do not validate any shop values here by now, nor do we check
        # for any empty values.
        if not isinstance(data, Shop):
            raise TypeError("Could not update Shop. Argument 'data' must be of type 'Shop'.")

        # Deep conversion: Shop object to dict, which is the expected data type of super.update()
        dataDict = self._encodeShop(data)  # raises

        # Update record.
        super().update(data=dataDict)  # raises

    def find(self, **kwargs) -> Union[Shop, List[Shop]]:
        """ Find one ore more shops, depending on given args.

        :param kwargs: 'uid': Find a Shop by its UID.
        :return: A Shop list if Shops where found (or a single Shop -
                 depends on kwargs).
        :raises: If no shops were found.
        """
        if "uid" in kwargs:
            return self._findByUID(kwargs["uid"])  # raises

        elif "shopName" in kwargs:
            return self._findByName(kwargs["shopName"])  # raises

        else:
            raise KeyError(f"Shop search fail. None of the expected arguments were given. "
                           f"kwargs: {kwargs}")

    def _findByUID(self, uid: str) -> Shop:
        """ Searches a Shop record (inside the 'Shops' table) with the given Shop UID.

        :param uid: A shop's UID to search for
        :return: A Shop if one single Shop was found
        :raises: When UID was not found, or multiple UIDs were found
        """
        uidQuery = tdb.Query().uid == uid  # prepare statement
        results = super().find(condition=uidQuery)  # raises

        if isinstance(results, list):
            foundCount = len(results)

            if foundCount == 1:
                decodedShops = self._decodeShops(shopItems=results)
                return decodedShops[0]

            elif foundCount == 0:
                raise LookupError(f"No shops found with UID {uid}")

            elif foundCount > 1:
                raise LookupError(f"Shop UID search fail. Found multiple shops: {results}")

    def _findByName(self, name: str) -> List[Shop]:
        """ Searches a Shop record (inside the 'Shops' table) with the given Shop UID.

        :param name: A shop's name to search for
        :return: List of shops if found, else raises
        :raises: When no shop was found
        """
        shopNameQuery = tdb.Query().name == name  # prepare statement
        results = super().find(condition=shopNameQuery)  # raises

        if isinstance(results, list):
            foundCount = len(results)

            if foundCount > 0:
                decodedShops = self._decodeShops(shopItems=results)
                return decodedShops

            else:
                raise LookupError(f"No shops found with name '{name}'")

    @classmethod
    def _encodeShop(cls, shop: Shop) -> dict:
        # Object to dict to JSON string (traverse)
        shopJsonStr = json.dumps(shop.__dict__, default=lambda o: o.__dict__)  # raises

        # Key names are usually autogenerated from the attribute name. For attributes
        # which hold an instance of a different class, the __dict__ hook generates
        # a concatenated qualified key name.
        # Ex.: Attribute 'products' in class 'Shop' holds a list of 'Product' objects. This
        # becomes a qualified key name '_Shop__products'.
        # Replace these keys named e.g. '_Shop__products' with 'products' etc.
        shopJsonStr = shopJsonStr \
            .replace(f"_{Shop.__name__}__", "") \
            .replace(f"_{Product.__name__}__", "") \
            .replace(f"_{Size.__name__}__", "")

        # Convert final JSON string to dict
        return json.loads(shopJsonStr)  # raises

    @classmethod
    def _decodeShops(cls, shopItems: List[dict]) -> List[Shop]:
        decodedShops: List[Shop] = list()
        for shopItem in shopItems:
            shopItem: tdb.database.Document
            shop = Shop(**shopItem)
            shop.products = cls._decodeProducts(shop.products)
            decodedShops.append(shop)
        return decodedShops

    @classmethod
    def _decodeProducts(cls, productItems: list) -> List[Product]:
        decodedProducts: List[Product] = list()
        for productItem in productItems:
            product = Product(**productItem)
            product.sizes = cls._decodeSizes(product.sizes)
            decodedProducts.append(product)
        return decodedProducts

    @classmethod
    def _decodeSizes(cls, sizeItems: list) -> List[Size]:
        decodedSizes: List[Size] = list()
        for sizeItem in sizeItems:
            size = Size(**sizeItem)
            decodedSizes.append(size)
        return decodedSizes